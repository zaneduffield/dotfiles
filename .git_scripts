#!/bin/bash
#shellcheck disable=SC2139,SC2064

alias g='git'
alias gs='git status'
alias gc='git checkout'
alias gri='git rebase -i'
alias gmt='git mergetool'
alias grim='gri master'
alias stash='git stash'
alias pop='git stash pop'
alias sps='git stash && git pull && git stash pop'
alias clean='git clean -fdx -e ".vscode/" -e ".idea"'
alias k='gitk -n100'

if [[ $(type -t gitRoot) != function ]]; then
  # Roughly equivalent to `git rev-parse --show-toplevel`, but much, much faster (e.g. 1ms vs 100ms).
  gitRoot() {
    local dir=$PWD
    while [ -n "$dir" ] && ! [ -e "$dir/.git" ]; do
      dir=${dir%/*}
    done

    if [ -z "$dir" ]; then
      1>&2 echo "not a git repository"
      return 1
    fi

    printf "%s\n" "$dir"
  }
fi

gitRootWin() {
  local root
  root=$(gitRoot)
  if [[ "$root" =~ ^/([a-zA-Z])/(.*)$ ]]; then
    root=${BASH_REMATCH[1]^}:/${BASH_REMATCH[2]}
  fi

  printf %s "$root"
}

alias root='cd "$(gitRoot)"'

alias gh-pr-involves-me='gh pr list --search "involves:@me state:open"'

function gl {
  local s="▕"
  git log --color=always --date=relative -n 300 \
    --pretty=format:"%D$s%C(yellow)%h$s%Cred%cd$s%C(cyan)%aN$s%C(cyan)%cN$s%Creset%s$s%(trailers:separator=; )" "$@" | \
    column --table --separator "$s" --output-separator "$s" | \
    awk -F $s '
      { aN = 4; last = 6; cN = 5; trailers = 7 }
      { endTrailerPrefix = "└─ "; trailerPrefix = endTrailerPrefix }
      { if ($1 ~ /[^ ]/) printf "  \033[1;32m┌─ %s\n", $1 }
      {
        if (gensub(/^ *| *$/, "", "g", $aN) == gensub(/^ *| *$/, "", "g", $cN)) { $cN = "\033[0;35m" $cN }
      }
      { for (i=2; i<=last; i++) printf "%s ", $i }
      { if ($trailers ~ /[^ ]/) printf "\n  \033[0;35m%s%s", trailerPrefix, $trailers }
      {
        print ""
      }
      ' | \
    less -R -S -# 5
}
export -f gl

function gg {
  git log --graph --all --date=relative --abbrev-commit --decorate --color=always \
    --format=format:'%C(yellow)%h %C(red)%cd %C(cyan)%aN %C(reset)%s %C(bold yellow)%d%C(reset)' \
    "$@" | less -R -S -# 5
}

function __git_wrap__git_log() {
  __git_func_wrap _git_log
}
complete -F __git_wrap__git_log gl

function diffall {
  local counter=0 total
  total=$(git diff --name-only "$@" | wc -l)
  git diff --name-only "$@" | while read -r filename; do
      (( counter=counter+1 ))
      echo "$filename"

      mod=$((counter % 50))
      if [ "$mod" -eq "0" ]
      then
        echo "Diffing $counter out of $total files"
        git difftool --no-prompt -- "$filename" || break
        continue
      fi
      git difftool --no-prompt -- "$filename" &
  done
}

function __git_wrap__git_diff() {
  __git_func_wrap _git_diff
}
complete -F __git_wrap__git_diff diffall

alias commit='git commit -v'
alias fixup='git commit -v --fixup'
alias amend='git commit --amend -v'
alias noedit='git commit --amend --no-edit'
alias rebase='git rebase'
alias revert='git revert'
alias gcp='git cherry-pick'

cont() {
  local gitState
  if [[ "${PS1@P}" =~ .*\([^\)]*\|([[:alpha:]-]+)[^\)]*\) ]]; then
    gitState=${BASH_REMATCH[1]}
  else
    1>&2 echo 'Failed to parse git state from PS1'
    return 1
  fi

  if [ "$gitState" == "REBASE" ]; then
    git rebase --continue
  elif [ "$gitState" == "MERGING" ]; then
    git merge --continue
  elif [ "$gitState" == "CHERRY-PICKING" ]; then
    git cherry-pick --continue
  elif [ "$gitState" == "REVERTING" ]; then
    git revert --continue
  else
    1>&2 echo "Cannot continue in this git state: $gitState"
    return 1
  fi
}

mergeToMaster() (
  set -x
  git checkout master && \
  git pull && \
  git checkout - && \
  rebase master -i && \
  git checkout - && \
  git merge - && \
  git status
)

rebaseAll() (
  export dryRun=0
  if [ "${1-}" == "--dry-run" ]; then
    dryRun=1 && shift;
  fi

  local branch=$1
  if [ -z "$branch" ]; then
    1>&2 echo 'USAGE: rebaseAll [--dry-run] <NEWBASE> [<regex>]'
    return 1
  fi
  shift

  local regex=${1:-.*}

  ((failCount=0))

  # shellcheck disable=SC2016
  # only rebase branches without an upstream
  git branch --format '%(refname)' |
      git for-each-ref --stdin --format "%(refname:short) %(upstream)" |
      awk '{if (!$2) print $1;}' |
      grep -vE "$branch"'|^\+arch|^review/|^pr/' |
      grep -E "$regex" |
      xargs -P16 -I {} bash -c '
        '"branch=$(printf %q "$branch")"'
        b={}
        if [ "$dryRun" == "1" ]; then 1>&2 echo "$b"; exit 0; fi

        if ! git replay --onto "$branch" "$branch..$b"; then
          1>&2 echo "ERROR: branch $b has conflicts"
          exit 1
        fi
        1>&2 echo "successfully rebased $b onto $branch"
      ' |
      git update-ref --stdin
)

function ls-files {
  git ls-files -- ":(icase)$*"
}

function fzfSelectFilesWithPreview {
  fzf --height 50% --min-height 20 --border --bind ctrl-/:toggle-preview \
    --multi --select-1 --exit-0 \
    --preview-window 30% \
    --preview 'bat --style=numbers --color=always --line-range :300 {}' \
    "$@"
}

function mySelect {
  readarray -t opts

  if [[ "${#opts[@]}" -eq 1 ]]; then
    echo "${opts[0]}"
    return 0
  fi

  select opt in "${opts[@]}"
  do
    #shellcheck disable=SC2076
    if [[ ! "${opts[*]}" =~ "$opt" ]]; then
      >&2 echo "$opt was not an option"
      return 1
    fi
    echo "$opt"
    break
  done < /dev/tty
}

function open {
  git ls-files |
    { fzfSelectFilesWithPreview -q "${1//\*/}" || >&2 echo 'no matches' && return 1; } |
    while read -r file; do
      [ -n "$file" ] && echo "$file" && start "$file" && sleep 0.1s
    done
}

function modifyCommitMessages {
  local messageCallback revrange
  revrange="$1"
  messageCallback="$2"

  git filter-repo --message-callback "$messageCallback" --refs "$revrange" --force
}

function appendIfNotPresent {
  message="$2"
  local messageCallback="
  if b'$message' not in message:
    message += b'$message'
  return message
  "

  modifyCommitMessages "$1" "$messageCallback"
}

appendReviewer() (
  set -u
  local reviewer="$1"
  local revRange="${2-HEAD~..}"
  if [[ ! "$revRange" =~ \.\. ]]; then
    >&2 echo "rev range should contain '..'"
    return 1
  fi
  appendIfNotPresent "$revRange" "\ncode-reviewed-by: $reviewer"
)

deleteMergedBranches() {
  git branch --merged "$@" | grep -Ev "(^\*|master|main|dev)" | xargs -r git branch -d
}

deleteBranchesWithoutMe() {
  local name
  name=$(git config user.name)

  while read -r b; do
    if [ -z "$(git log --author "$name" master.."$b")" ]; then
      while true; do
        read -p "Branch $b contains no commits from author $name, delete? y/N/log: " resp < /dev/tty
        if [[ "$resp" == [lL]* ]]; then
          gl master.."$b" | cat
          continue
        elif [[ "$resp" == [yY]* ]]; then
          git branch -D "$b"
          break
        elif [[ "$resp" == [nN]* ]]; then
          break
        fi
      done
    fi
  done < <(
    git branch --list --format="%(refname:short) %(upstream:track)" |
    awk '$2=="" { print $1 }'
  )
}

